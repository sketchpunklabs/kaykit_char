<!DOCTYPE html><html lang="en"><head><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<link rel="stylesheet" href="./ui/panel.css">
<body><div id="ui" class="floatPanel topLeft" style="width:300px;"></div>
<script src="./import-map.js"></script><script type="module">
// #region IMPORTS
    import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '@lib/useThreeWebGL2.js';
    import { GLTFLoader }       from 'three/GLTFLoader.js';

    import * as util            from '@lib/util.js';
    import { FrameTaskQueue, PopMeshTask } from '@lib/misc/FrameTaskQueue.js';
    import CRTFaceMaterial      from '@lib/shader/CRTFaceMaterial.js';
    import Easing               from '@lib/maths/Easing.js';

    import { render }               from '@tp/preact/preact.mjs';
    import { useSignal, effect }    from '@tp/preact/signals.mjs';
    import { deepSignal, peek, shallow }           from '@tp/preact/deepsignal.mjs';
    import { html }                 from '@tp/preact/htm_preact.mjs';
    import { PanelSection, RowSelect } from '@ui/index.js';
// #endregion

// #region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {
    med_char    : { path:'./res/models/mannequin_v2/manny_med_mod.gltf', obj: null, handl:null, handr:null, head:null, screen:null, },
    queue       : new FrameTaskQueue(),
    mixer       : new THREE.AnimationMixer( new THREE.Object3D() ),
    ease        : Easing.fnTuneBounce(),
    action      : null,

    initPack    : 0,
    initClip    : 0,

    propFiles   : [
        './res/models/pete/pete_gear.gltf',
        './res/models/props.glb',
    ],

    activeProps : [],
    clipProps   : [
        { look:'1H_Attack', props:[{ place:'handr', prop:'Sword'}] },
        { look:'2H_Attack', props:[{ place:'handr', prop:'Axe_2handed'}] },
        { look:'2H_Idle', props:[{ place:'handr', prop:'Axe_2handed'}] },
        { look:'Melee_Block', props:[{ place:'handr', prop:'Sword'}, { place:'handl', prop:'Shield'}] },
        { look:'Dualwield', props:[{ place:'handr', prop:'Sword'}, { place:'handl', prop:'Axe_1handed'}] },
        { look:'Ranged_1H', props:[{ place:'handr', prop:'Crossbow_1handed'}] },
        { look:'Ranged_2H', props:[{ place:'handr', prop:'Crossbow_2handed'}] },
        { look:'Ranged_Magic', props:[{ place:'handr', prop:'Skeleton_Staff'}] },
        { look:'Throw', props:[{ place:'handr', prop:'Mug_empty'}] },
        { look:'Use_Item', props:[{ place:'handr', prop:'Mug_empty'}] },
        { look:'Chair', props:[{ place:'scene', prop:'Chair'}] },
        { look:'Ranged_Bow', props:[{ place:'handl', prop:'Bow'}] },
        { look:'Running', props:[{ place:'head', prop:'Helmet'}] },
    ],
};

let Store = deepSignal({
    isReady : false,
    packSel : Ref.initPack,
    clipSel : null,
    packs   : [
        { name:"Movements Basic", char:'med_char', path:'./res/anim/Med_MovementBasic.glb', clips:shallow({ ref:[] }) },
        { name:"Movements Advanced", char:'med_char', path:'./res/anim/Med_MovementAdvanced.glb', clips:shallow({ ref:[] }) },
        { name:"Combat Melee", char:'med_char', path:'./res/anim/Med_CombatMelee.glb', clips:shallow({ ref:[] }) },
        { name:"Combat Ranged", char:'med_char', path:'./res/anim/Med_CombatRanged.glb', clips:shallow({ ref:[] }) },
        { name:"General", char:'med_char', path:'./res/anim/Med_General.glb', clips:shallow({ ref:[] }) },
        { name:"Simulation", char:'med_char', path:'./res/anim/Med_Simulation.glb', clips:shallow({ ref:[] }) },
        { name:"Special", char:'med_char', path:'./res/anim/Med_Special.glb', clips:shallow({ ref:[] }), clean:false, },
    ],
    props   : {
        Shield              : shallow( { mesh:null, pos:[0,0,0.1], rot:[0,Math.PI * 0.25,0 ] } ),
        Sword               : shallow( { mesh:null, rot:[0,Math.PI * 0.5,0 ] } ),
        Axe_1handed         : shallow( { mesh:null, rot:[0,Math.PI * 0.5,0 ] } ),
        Axe_2handed         : shallow( { mesh:null, rot:[0,Math.PI * 0.5,0 ], pos:[0,0.22,0] } ),
        Crossbow_1handed    : shallow( { mesh:null, } ),
        Crossbow_2handed    : shallow( { mesh:null, } ),
        Mug_empty           : shallow( { mesh:null, rot:[0,Math.PI * 0.5,0], pos:[0,0,0.3] } ),
        Chair               : shallow( { mesh:null, rot:[0,Math.PI * 0.5,0], pos:[0,0,-0.2] } ),
        Skeleton_Staff      : shallow( { mesh:null, rot:[0,Math.PI * 0.5,0] } ),
        Bow                 : shallow( { mesh:null, rot:[Math.PI * 0.5,Math.PI * -0.5,0]} ),
        Helmet              : shallow( { mesh:null, pos:[0,-0.03,-0.03] } ),
    },

    faceSel : 0,
    faces   : [
        { name: 'BoyWithUke', value:0 },
        { name: 'Question', value:1 },
        { name: 'Meow', value:2 },
        { name: 'Meh', value:3 },
        { name: 'Heart', value:4 },
    ],
});

// CLIP : Play clip when selected
effect( ()=>{
    // return;
    const idx = Store.clipSel;
    if( idx != null && peek( Store, 'isReady' ) ){
        const pIdx = peek( Store, 'packSel' )
        const clip = Store.packs[pIdx].clips.ref[idx]
        playClip( clip );
    }
} );

// PACKS : Load or Download
effect( ()=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const packs = peek( Store, 'packs' );
    const pIdx  = Store.packSel;

    if( !peek(Store, 'isReady') ) return;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const pack  = packs[ pIdx ];
    if( pack.clips.ref.length > 0 ){
        // CLIPS DOWNLOADED
        // If ClipSel is zero, it won't trigger effect
        // So set it to null then back to 0.
        Store.clipSel = null;
        Store.clipSel = 0;
    }else{
        // DOWNLOAD CLIPS
        showLoader( true )
        Store.clipSel = null;
        loadAnimation( pack ).then( ()=>{
            showLoader( false );
            Store.clipSel = 0;
        });
    }

    console.log( 'PackSel', pIdx, 'clipSel', pack.clips.ref.length );
});

// FACE : Change Face Render
effect( ()=>{
    const idx  = Store.faceSel;
    if( Ref.med_char.screen ) Ref.med_char.screen.face = idx;
} );

window.addEventListener( 'load', async ()=>{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	App.sphericalLook( 25, 10, 5, [0,1,0] );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    showLoader( true );
    initLoading( Store.packs[ Ref.initPack ] ).then( ()=>{
        // setTimeout( ()=>{
        //     Ref.med_char.handl.add( Store.props.Bow.mesh );
        //     // Ref.med_char.handl.add( Store.props.Axe_2handed.mesh );
        // }, 500 )
    });

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.createRenderLoop( onPreRender ).start();
    appendGithubLink(false);
});

function onPreRender( dt, et ){
    if( Ref.action ) Ref.mixer.update( dt );
    Ref.queue.process( dt, et );
}

function UI(){
    // Packs
    const pSel   = Store.packSel;
    const pItems = Store.packs.reduce( (o,v,i)=>{ v.char === 'med_char' && (o[ v.name ] = i); return o; }, {} );
    const onPack = e=>{ Store.packSel = e.target.value };

    // Clips
    const clips  = Store.packs[ pSel ].clips.ref;
    const cItems = clips.map((v,i)=>v.name.substr( v.name.indexOf('|') +1 ));
    const onClip = e=>{ Store.clipSel = e.target.value };

    // Faces
    const fItems = Store.faces.map( (v,i)=>v.name );
    const onFace = e=>{ Store.faceSel = e.target.value };

    return html`
        <${PanelSection} title='Animation'>
            <${RowSelect} value=${pSel} items=${pItems} label='Packs' onChange=${onPack}/>
            <${RowSelect} value=${Store.clipSel} items=${cItems} label='Clips' onChange=${onClip}/>
        <//>
        <${PanelSection} title='Face LED'>
            <${RowSelect} value=${Store.faceSel} items=${fItems} label='Faces' onChange=${onFace}/>
        <//>
    `;
}

render( html`<${UI}/>`, document.querySelector('#ui') );
// #endregion

// #region LOADING
    function showLoader( show=false ){
        const elm = document.getElementById( 'divLoading' );
        elm.style.display = show? 'flex' : 'none';
    }

    async function initLoading( initPack ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const [ch,clips] = await Promise.all( [
            loadChar( {
                state       : Ref.med_char,
                onSkinned   : ( m )=>(( m.name === 'Mannequin_Medium_Head_Screen' ) && ( Ref.med_char.screen = m.material = CRTFaceMaterial() ))
            }),
            loadAnimation( initPack ),
            loadProps( Ref.propFiles ),
        ] );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        showLoader( false );
        Store.isReady = true;
        Store.clipSel = Ref.initClip;
    }

    async function loadChar( props={} ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // LOAD
        const opt = { skel:true, matswap:null, onSkinned: null, tpose:false, ...props };
        const tf  = await new GLTFLoader().loadAsync( opt.state.path );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        let skel = null
        let mat  = null;
        for( const m of util.traverseFind( tf.scene, o=> (o.type === 'SkinnedMesh') ) ){
            // ------------------------------------
            switch( typeof opt.matswop ){
                case 'string':
                    switch( opt.matswop ){
                        case 'toon': m.material = new THREE.MeshToonMaterial( { map: m.material.map, normalMap: m.material.normalMap } ); break;
                    }
                    break;
            }

            // ------------------------------------
            if( opt.onSkinned ) opt.onSkinned( m );

            // ------------------------------------
            if( !skel ) skel = m.skeleton;  // First skeleton
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Setup sockets for placing
        for( const b of skel.bones ){
            switch( b.name ){
                case 'handl': opt.state.handl = wsAlignSocket( b, [0,0,1], [1,0,0], [0.1,0,0] ) ; break;
                case 'handr': opt.state.handr = wsAlignSocket( b, [0,0,1], [-1,0,0], [-0.1,0,0] ); break;
                case 'head':  opt.state.head  = b; break;
            }
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        opt.state.obj = { tf, skel };
        App.scene.add( tf.scene );

        return opt.state.obj;
    }

    async function loadAnimation( state ){
        const tf          = await new GLTFLoader().loadAsync( state.path );
        state.clips.ref   = tf.animations;
        return state.clips;
    }

    async function loadProps( ary ){
        const pAry = ary.map( i => new GLTFLoader().loadAsync( i ) );
        const gAry = await Promise.allSettled( pAry );

        for( const i of gAry ){
            i.value.scene.traverse( o=>{
                if( !o.isMesh ) return;

                o.rotation.reorder( 'YXZ' );
                // console.log( o.name );

                if( Store.props[ o.name ] ){
                    // Custom Transform Exists
                    const p = Store.props[ o.name ];
                    if( p.pos )  o.position.fromArray( p.pos );
                    if( p.rot )  o.rotation.fromArray( p.rot );
                    if( p.quat ) o.quaternion.fromArray( p.quat );
                    p.mesh = o;
                }else{
                    // Add to the store
                    Store.props[ o.name ] = shallow( { mesh:o } );
                }
            });
        }
    }
// #endregion

// #region CLIPS / ANIMATIONS
    function playClip( c ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if( !c._isCleaned && Store.packs[ Store.packSel ].clean !== false ){
            cleanTracks( c );
            c._isCleaned = true;
        }

        if( Ref.action ){
            Ref.action.stop();
            Ref.action = null;
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const tf = Ref.med_char.obj.tf;
        Ref.action = Ref.mixer.clipAction( c, tf.scene );
        Ref.action.play();

        showClipProps( c.name );
    }

    // Remove unneeded tracks to optimize animation
    function cleanTracks( clip ){
        // All positions except for root & hips, also remove handslot
        const pat = '((\\b(?!(root|hips))\\w+\\.position)|handslot)';
        const re  = new RegExp( pat, 'i' );

        let tr;
        for( let i = clip.tracks.length - 1; i >=0; i-- ){
            tr = clip.tracks[ i ];
            if( re.test( tr.name )){
                // console.log( tr.name );
                clip.tracks.splice( i, 1 );
            }
        }
    }
// #endregion

// #region PROPS
    function wsAlignSocket( bone, toUp=[0,0,1], toFwd=[0,-1,0], toPos=[0,0,0] ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Compute quaternion rotation based on vector directions
        const vUP  = new THREE.Vector3().fromArray( toUp );
        const vFWD = new THREE.Vector3().fromArray( toFwd );
        const vRIT = new THREE.Vector3().crossVectors( vUP, vFWD );
        vUP.crossVectors( vFWD, vRIT );

        const m4   = new THREE.Matrix4();
        m4.makeBasis( vRIT, vUP, vFWD );

        const q    = new THREE.Quaternion().setFromRotationMatrix( m4 );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Tranform position & rotation to localspace of the bone
        const rot  = new THREE.Quaternion()
        const pos  = new THREE.Vector3();
        const p    = new THREE.Vector3();
        const v    = new THREE.Vector3().fromArray( toPos );
        const scl  = new THREE.Vector3( 1, 1, 1 )
        bone.getWorldQuaternion( rot );
        bone.getWorldPosition( pos );

        // To Local Position
        p.copy( pos ).add( v );
        m4.compose( pos, rot, scl );
        p.applyMatrix4( m4.invert() );

        // To Local Rotation
        // const qq = q.clone(); // 4Debug
        q.premultiply( rot.invert() );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // VISUALLY DEBUG ROTATION/ POS
        // const vv = new THREE.Vector3();
        // vv.copy( pos ).add( v );
        // Debug.pnt.add( vv.toArray(), 0x00ff00, 3  );

        // v.set( 0,0,1 ).applyQuaternion( qq ).add( vv );
        // Debug.ln.add( vv.toArray(), v.toArray(), 0x0000ff );
        // v.set( 0,1,0 ).applyQuaternion( qq ).add( vv );
        // Debug.ln.add( vv.toArray(), v.toArray(), 0x00ff00 );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const socket = new THREE.Group();
        socket.quaternion.copy( q );
        socket.position.copy( p );
        bone.add( socket );

        return socket;
    }

    function compareSets( sa, sb ){
        const added     = sb.difference( sa );      // What is in New but NOT in Original (Added)
        const same      = sb.intersection( sa );    // What is in both (Same)
        const missing   = sa.difference( sb );      // What is in Original but NOT in New (Missing)
        return {
            added   : Array.from( added ),
            same    : Array.from( same ),
            missing : Array.from( missing )
        };
    }

    function showClipProps( cName ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const found = {};
        for( const i of Ref.clipProps ){
            // console.log( cName, i.look, cName.includes( i.look ) );
            if( cName.includes( i.look ) ){
                for( const j of i.props ) found[ j.prop ] = j.place;
                break;
            }
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const newProps = new Set( Object.keys( found ) );
        const oldProps = new Set( Ref.activeProps.map( i=>i.name) );
        const compare  = compareSets( oldProps, newProps );

        const rtn      = [];

        compare.same.forEach( i=>rtn.push( Store.props[ i ].mesh ) );

        compare.added.forEach( i=>{
            const m = Store.props[ i ].mesh;
            switch( found[i] ){
                case 'handl'    : Ref.med_char.handl.add( m ); break;
                case 'handr'    : Ref.med_char.handr.add( m ); break;
                case 'head'     : Ref.med_char.head.add( m ); break;
                case 'scene'    : App.scene.add( m );
            }

            console.log( 'added', i );
            rtn.push( m );
            Ref.queue.enqueue( PopMeshTask.show( m, 1.5, Ref.ease ) );
        });

        compare.missing.forEach( i=>{
            const m = Store.props[ i ].mesh;
            console.log( 'missing', i );
            Ref.queue.enqueue( PopMeshTask.hide( m, 1.5, Easing.expOut ) );
        });

        Ref.activeProps = rtn;
    }
// #endregion
</script>

<div id="divLoading" style="display:none; position:fixed; margin:0 auto; inset:5px 0 auto 0; z-index:100; border:0px solid red; height:fit-content; width:fit-content; flex-direction:row; align-items:center; gap:5px;">
    <svg fill="#00FF2DFF" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width:30px;"><rect x="1" y="6" width="2.8" height="12"><animate id="spinner_CcmT" begin="0;spinner_IzZB.end-0.1s" attributeName="y" calcMode="spline" dur="0.6s" values="6;1;6" keySplines=".36,.61,.3,.98;.36,.61,.3,.98"/><animate begin="0;spinner_IzZB.end-0.1s" attributeName="height" calcMode="spline" dur="0.6s" values="12;22;12" keySplines=".36,.61,.3,.98;.36,.61,.3,.98"/></rect><rect x="5.8" y="6" width="2.8" height="12"><animate begin="spinner_CcmT.begin+0.1s" attributeName="y" calcMode="spline" dur="0.6s" values="6;1;6" keySplines=".36,.61,.3,.98;.36,.61,.3,.98"/><animate begin="spinner_CcmT.begin+0.1s" attributeName="height" calcMode="spline" dur="0.6s" values="12;22;12" keySplines=".36,.61,.3,.98;.36,.61,.3,.98"/></rect><rect x="10.6" y="6" width="2.8" height="12"><animate begin="spinner_CcmT.begin+0.2s" attributeName="y" calcMode="spline" dur="0.6s" values="6;1;6" keySplines=".36,.61,.3,.98;.36,.61,.3,.98"/><animate begin="spinner_CcmT.begin+0.2s" attributeName="height" calcMode="spline" dur="0.6s" values="12;22;12" keySplines=".36,.61,.3,.98;.36,.61,.3,.98"/></rect><rect x="15.4" y="6" width="2.8" height="12"><animate begin="spinner_CcmT.begin+0.3s" attributeName="y" calcMode="spline" dur="0.6s" values="6;1;6" keySplines=".36,.61,.3,.98;.36,.61,.3,.98"/><animate begin="spinner_CcmT.begin+0.3s" attributeName="height" calcMode="spline" dur="0.6s" values="12;22;12" keySplines=".36,.61,.3,.98;.36,.61,.3,.98"/></rect><rect x="20.2" y="6" width="2.8" height="12"><animate id="spinner_IzZB" begin="spinner_CcmT.begin+0.4s" attributeName="y" calcMode="spline" dur="0.6s" values="6;1;6" keySplines=".36,.61,.3,.98;.36,.61,.3,.98"/><animate begin="spinner_CcmT.begin+0.4s" attributeName="height" calcMode="spline" dur="0.6s" values="12;22;12" keySplines=".36,.61,.3,.98;.36,.61,.3,.98"/></rect></svg>
    <div style="color:#00FF2D; font-size:18px; font-family:monospace;">LOADING</div>
</div>

</body></html>
